/* control_task.c */
#include "FreeRTOS.h"
#include "task.h"
#include "queue.h"
#include "control_logic.h"

// Definições de Tempo e Alarmes
#define CONTROL_CYCLE_MS  100   // Ciclo de controle (rápido para resposta)
#define MODBUS_TIMEOUT_MS 2000  // Tempo máximo sem dados antes de declarar falha

// Filas (Devem ser criadas no main.c)
extern QueueHandle_t xQueueModbusToControl; // Dados chegando do CLP
extern QueueHandle_t xQueueHmiToControl;    // Comandos do Usuário
extern QueueHandle_t xQueueControlToModbus; // Comandos para o CLP
extern QueueHandle_t xQueueControlToHmi;    // Status para atualizar Tela

void Task_Control(void *pvParameters) {
    ModbusData_t inputData;
    HmiCommands_t userCmd;
    SystemStatus_t systemState;

    // Estado inicial padrão
    userCmd.modo_operacao = 0; // Inicia em Manual por segurança
    userCmd.comando_manual = 0;
    systemState.alarme_ativo = 0;
    
    TickType_t xLastWakeTime;
    xLastWakeTime = xTaskGetTickCount();

    for (;;) {
        // 1. LEITURA DE DADOS (Consumir filas)
        // Verifica se chegaram dados novos do Modbus
        if (xQueueReceive(xQueueModbusToControl, &inputData, 0) == pdFALSE) {
            // Se a fila estiver vazia por muito tempo, considerar erro de comunicação
            // Lógica simplificada: assumimos que Task_Modbus envia periodicamente
            inputData.conexao_ok = 0; 
        }

        // Verifica comandos da IHM (não bloqueante)
        xQueueReceive(xQueueHmiToControl, &userCmd, 0);

        // 2. TRATAMENTO DE FALHAS E ALARMES [cite: 24, 47]
        // Prioridade máxima: Segurança
        if (inputData.conexao_ok == 0) {
            systemState.alarme_ativo = 3; // Erro de Comunicação
            systemState.acionar_bomba = 0; // SEGURANÇA: Desliga bomba se perder rede
        } else {
            // Lógica de Alarmes de Nível [cite: 38]
            if (inputData.sensor_nivel_alto == 1) {
                 systemState.alarme_ativo = 2; // Tanque Cheio (Aviso)
            } else if (inputData.sensor_nivel_baixo == 0) {
                 systemState.alarme_ativo = 1; // Nível Crítico Baixo
            } else {
                 systemState.alarme_ativo = 0; // Normal
            }
        }
        
        // Reset de alarmes pelo usuário [cite: 42]
        if (userCmd.reset_alarmes) {
            systemState.alarme_ativo = 0;
            userCmd.reset_alarmes = 0; // Limpa flag
        }

        // 3. MÁQUINA DE ESTADOS DE CONTROLE [cite: 40, 41]
        if (systemState.alarme_ativo == 3) {
            // Se há erro de comunicação, força desligamento
            systemState.acionar_bomba = 0; 
            
        } else if (userCmd.modo_operacao == 0) { 
            // --- MODO MANUAL ---
            // O usuário tem controle total, exceto se houver travas físicas no CLP
            systemState.acionar_bomba = userCmd.comando_manual;
            
        } else {
            // --- MODO AUTOMÁTICO ---
            // Lógica de Histerese para enchimento do tanque
            if (inputData.sensor_nivel_baixo == 0) {
                // Se nível baixo inativo (tanque vazio) -> Liga Bomba
                systemState.acionar_bomba = 1;
            } 
            else if (inputData.sensor_nivel_alto == 1) {
                // Se nível alto ativo (tanque cheio) -> Desliga Bomba
                systemState.acionar_bomba = 0;
            }
            // Se estiver entre os sensores, mantém o estado anterior
        }

        // 4. ATUALIZAÇÃO DO SISTEMA (Produzir filas)
        // Envia comando para Task_Modbus escrever no CLP
        xQueueSend(xQueueControlToModbus, &systemState.acionar_bomba, 0);

        // Envia estado completo para Task_Display atualizar a IHM [cite: 33-36]
        // Nota: Pode-se criar uma struct maior combinando inputData e systemState
        xQueueSend(xQueueControlToHmi, &systemState, 0);

        // Garante periodicidade de execução (Requisito Tempo Real: < 500ms) [cite: 45]
        vTaskDelayUntil(&xLastWakeTime, pdMS_TO_TICKS(CONTROL_CYCLE_MS));
    }
}
